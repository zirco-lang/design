# Zirco programming language grammar
#
# https://github.com/zirco-lang

# Note: This document is a work-in-progress.

# Operator precedence:
# 1. Comma
# 2. Ternary
# 3. Logical (AND/OR) << NOTE: Logical AND/OR are at the same level unlike C, requiring explicit parenthesis.
# 4. Equality         << NOTE: Equality is above bitwise unlike C, so A & B == C is (A & B) == C, not requiring explicitness.
# 5. Bitwise
# 6. Comparison
# 7. Bit Shift
# 8. +-
# 9. */%
# 10. Unary
# 11. Postfix
# 12. Primary

program = <declaration-list>;

declaration-list = (<declaration>)*;
                 
# See https://en.wikipedia.org/wiki/Dangling_else#Avoiding_the_conflict_in_LR_parsers for why this is necessary.
# The ClosedStmt rule REQUIRES that an 'else' clause is used, meaning that it will attach to the inner 'if' statement.

statement = <open-stmt> | <closed-stmt>;

open-stmt = "if" "(" <expression> ")" <statement>
          | "if" "(" <expression> ")" <closed-stmt> "else" <open-stmt>
          | "while" "(" <expression> ")" <open-stmt>
          | "for" "(" <declaration> ";" <expression> ";" <expression> ")" <open-stmt>;

closed-stmt = <simple-stmt>
            | "if" "(" <expression> ")" <closed-stmt> "else" <closed-stmt>
            | "while" "(" <expression> ")" <closed-stmt>
            | "for" "(" <declaration> ";" <expression> ";" <expression> ")" <closed-stmt>;

simple-stmt = <expression> ";"
            | ";"
            | "{" <stmt-list>? "}"
            | <flow-stmt>
            | <declaration>;

declaration = <let-declaration> | <function-declaration>;

function-declaration = "fn" <IDENTIFIER> "(" <argument-declaration-list>? ")" ("->" <type>)? "{" <stmt-list>? "}";

argument-declaration-list = <argument-declaration> ("," <argument-declaration>)* ","?;

argument-declaration = <IDENTIFIER> (":" <type>)?;

let-declaration = "let" <single-declaration> ("," <single-declaration>)* ";";

single-declaration = <IDENTIFIER> (":" <type>)? ("=" <expression>)?;

# TODO: more type stuff
type = <IDENTIFIER>;

flow-stmt = "continue" ";"
          | "break" ";"
          | "return" <expression> ";"
          | "return" ";";

stmt-list = <statement>+;

expression = <expression> "," <assignment-expression>
           | <assignment-expression>;

assignment-expression = <unary-expression> <assignment-operator> <assignment-expression>
                      | <ternary-expression>;

assignment-operator = "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|="
                    | "^=" | "<<=" | ">>=";

unary-expression = <unary-operator> <unary-expression>
                 | "++" <unary-expression>
                 | "--" <unary-expression>
                 | <postfix-expression>;

unary-operator = "!" | "~" | "-";

postfix-expression = <postfix-expression> "[" <expression> "]"
                   | <postfix-expression> "(" <argument-list>? ")"
                   | <postfix-expression> "." <IDENTIFIER>
                   | <postfix-expression> "::" <IDENTIFIER>
                   | <postfix-expression> "++"
                   | <postfix-expression> "--"
                   | <primary>;

argument-list = <argument-list> "," <assignment-expression>
              | <assignment-expression>;

ternary-expression = <logical-expression> "?" <expression> ":" <ternary-expression>
                   | <logical-expression>;

logical-expression = <logical-expression> <logical-operator> <equality-expression>
                   | <equality-expression>;

logical-operator = "&&" | "||";

equality-expression = <equality-expression> <equality-operator> <bitwise-expression>
                    | <bitwise-expression>;

equality-operator = "==" | "!=";

bitwise-expression = <bitwise-expression> <bitwise-operator> <comparison-expression>
                   | <comparison-expression>;

bitwise-operator = "|" | "&" | "^";

comparison-expression = <comparison-expression> <comparison-operator> <bit-shift-expression>
                      | <bit-shift-expression>;

comparison-operator = ">" | ">=" | "<" | "<=";

bit-shift-expression = <bit-shift-expression> <bit-shift-operator> <term-expression>
                     | <term-expression>;

bit-shift-operator = "<<" | ">>";

term-expression = <term-expression> "+" <factor-expression>
                | <term-expression> "-" <factor-expression>
                | <factor-expression>;

factor-expression = <factor-expression> "*" <unary-expression>
                  | <factor-expression> "/" <unary-expression>
                  | <factor-expression> "%" <unary-expression>
                  | <unary-expression>;

primary = <IDENTIFIER> | <STRING> | <NUMBER> | "true" | "false" | "(" <expression> ")";
